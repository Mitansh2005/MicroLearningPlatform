 If you're using Create React app, just add the proxy to your package.json. If you're using parcel, just create a proxy RP with your proxy in it. And if you're using VIT, just add the proxy to your VIT config file. And that's it. That's how you proxy your requests to your backend API in development and avoid those cause issues. Now stick around for the rest of the video if you want a more in-depth explanation on how to proxy your API requests. So let's say you have a server side app that could be in any language or framework. I'm going to use Express. And this server allows users to get a list of all users. Okay. Thank you, co-pilot. So our app literally just responds with users and we should probably put IDs in here. And we're just going to pretend this is a real app and this data is coming from a real database. But right now we have a server that returns a list of users. So if I go to my browser and open up localhost8080 slash users, we should be able to see that list of users there. They are. So that all works great. And then you have your front-end app. And in this case, I'm using VIT, but the toolchain doesn't matter that much. And this app is going to need to display that list of users. So we'll need some state for the users. And then we'll need to actually display those users somehow. That looks fine. Are those the same details and name and email? No, it didn't have an email. I had an age, come on, co-pilot. And I'm going to add a little title in here. Let's call this our user app. And we should be able to see this in the browser too at localhost5173 for some reason. So let's take a look at that. And there is the user app, but we can't see any users because right now it's just that empty array, but that's fine. But now we need to make sure that we actually load that list of users from the server when our application loads. So I'm going to add in a use effect here. And when this happens, we're going to do an exios request. I guess I should import exios. And we are going to get users from the server. And remember, the server is running on port 8080. And it's localhost. So I'm going to need to go HTTP localhost port 8080 slash users perfect. Then once that's done, we'll set the users to be the data that comes back. If there's an error, let's console log it. I don't need to finally come on. And that's it. So when this app loads, we should go grab those users that we know already works that will give us an array that we should render into a list of users. So let's refresh this page and nothing happens. So let's take a look at the console and all my cause we've been blocked. And at this moment, you might be wondering what is cause. So if we check this out, we get a bunch of documentation, but cause is something we only have to think about when the origin of an HTTP request is different than the origin of the location the request is being made. And an origin is the scheme in this case, we're using HTTP, the domain in this case localhost and the port. And in this case, the server has 8080 and the client has 517 something. I don't remember 5173. Okay. So although the scheme and the domain are the exact same in this case, the port is different and that makes it a different origin. The react app is being served up on a different origin than the server than the API. And when my react app tries to make a request to my back end API, that isn't allowed. The browser isn't going to allow that unless my server side code says, yeah, that's totally fine. A request from localhost 5173 is cool with me. Browser let this request happen. Unless the server does that, the browser just isn't going to let it happen. So we have this cause issue. And you might try and fix this issue by going down a cause rabbit hole where you go to your server and you try and add cause middle where and you might end up doing something like that to allow requests from any front end or you might actually specify localhost 5173 or localhost 3000 more likely. But before we do anything like this, we really need to step back and think about how our front end and our back end are going to work together and how they're going to communicate in our production environment because my back end is an express app and in development, it runs on port 8080 on local host using node mon, but in production, it's not going to run on localhost. It's going to run somewhere on the internet and I'm probably going to access it with a real domain like whatever domain.com. My react app is running on port 5173 and should probably be running on port 3000 because I have a development server set up through VIT and any toolchain that you use with a react app is going to serve up your react app through some development server. But this is just for development. This isn't how your app is going to work in production. We don't use the dev server, we don't use port 3000. We just have to get the HTML CSS and JavaScript that is your react app onto the internet somehow. VIT and all the other special tooling goes away in production and there's many ways of hosting these front end static assets. But one plan is just to build the front end application into the HTML CSS and JavaScript, copy those files onto the server and just have your server serve those up to your users. So in this case, I would just have my express app serve my react static files. So if I go to myapp.com in the browser, I'll get my react app static files. But if I go to myapp.com slash users in this case, I would get this JSON response. So most of my response is going to be JSON responses. But if I just make a request to the root, I should serve my react app. But to make the difference between my JSON API endpoints and my react app more clear, I'll probably do something like put slash API in front of anything that is part of my JSON API. So the root is just my react app and then slash API is my JSON API. And this is a pretty simple way of deploying a react app because in the end, you only have to deploy one thing. You just deploy your server with all of the static react assets as part of your server. And a nice side effect of this is that we don't have to deal with cores anymore because we're always going to have the same origin. We're just hosting one app. We'll have one domain name and the origin will be the same for the react app and for the JSON API. And at the end of this video, I'll show you how to actually deploy this two railway using this technique. But let's get back to the react app. So I know I'm going to be serving this react app from the same origin as my server. And when I do that, I don't need to specify any of the origin stuff. If this is on the same server, I can just say go to slash users. It's going to be the same origin slash users and actually it should be slash API slash users in this case. And if I go and reload this page again, I'm going to get a different error message, which is 404 not found because slash API slash users doesn't exist on my react app dev server. And that's because it's searching for slash API slash users on my react app dev server instead of my express app. And in production, I have a plan for this. I'm going to make sure that my react app is served from my express app. But in development, I need a different plan to kind of mimic this behavior while keeping my react app development server separate from my express app server. So my plan is basically going to be to trick the browser into thinking that these two apps are on the same server. So if I make a request to slash API slash users, although it's going to go to my express app, which has a different origin, I want the browser to think that it's the same origin as my react app dev server. And in a VIT application, I just have to find the VIT.config.js and add a server parameter here, which has a proxy parameter, which has slash API, which is going to forward to local host 8080 because that's my express server. And this is the simplest way of using the VIT proxy. You can get way more fancy, you can use regular expressions and do a whole bunch of other things. But this is all I need. And all it's saying is any request that starts with slash API, that should be forwarded to local host 8080, which is my express app. But the browser is going to think that it's still part of my react app that they're still the same origin, but behind the scenes, we're going to forward everything onto the express app. And if you're using create react app, then you just open up your package.json and you add proxy. And then where you're proxying to. So in this case, local host 8080, if you're using parcel, you can create a dot proxy RC file and just dump in this bit of code right here. It really doesn't matter what your tool chain is. You'll most likely have a way of creating a proxy to your back end. And I'll leave some links to the documentation in the description of this video. So what this means is that in my react code, I get to write code like this where I just make requests as if they're on the same origin slash API slash users is going to go to my express server at a different origin, but the browser is going to think that the same origin in development and then in production, I'm just going to make sure they're the same origin. So now if I go back and refresh this page, it's not going to work. And I think that's because when I change something in my Viet config, I might have to restart the server. So let's try this again, refresh. And there we go. I have my application and here are my users coming from my API. And if I clear this real quick and then refresh the app, I should see that when I make a request to slash API slash users, my browser thinks that I'm making that request to my react apps dev server, but really it's being forwarded to my express app and I'm getting my express app to response here. And I can prove this by modifying this just a little bit. Let's see if we can add another user in here. Copilot going to help me ID three, Jack, do age 28 done. Okay. So I've updated my back in server, my express server running on port 8080, but this should still work just as if it was part of my front end app because we're forwarding all the requests that start with slash API to my express app. So no more cause issues and I get to write my requests as they will appear in production. So I get to omit that origin completely, which is really nice. So this is working in development, but let's see how we actually make this work in production. But before we do that, make sure you subscribe to this channel so you don't miss any future videos like this one. The first thing we need to do when we want to deploy a react app is actually build that app. So we're not going to use the dev server anymore. We're going to run Yarn build to build this down into its HTML CSS and JavaScript files that we can actually deploy with our server. And once we do that, we should get this little dist folder here, which has the index.html and any other assets that we need. So I'm going to just take this dist folder from my front end react repo and copy this straight into my express back end here. So my express app now has this dist folder. Then in my server.js, I'm going to remove this fake path here and I'm going to say app.use express.static. And this is going to be the dist folder. So now a request that comes in to slash index or just slash in this case will serve up the react app. So we could test this by opening up local host at 80. I know that if I go to slash API slash users, I'll get that array of users. But if I just go to local host at 80, which is my express application, I should see my react app being presented here. And this isn't the JSX and all the stuff in apps.jsX or anything like that. It is just that dist folder, just what was compiled when I ran Yarn build. So if I make any changes in app.jsX, if I add a few more piece here, this won't appear in my express version of the application because this will only get what I've built at that time. So if I made a change to my front end and I want to be able to see that in production on my express app, I would have to go and rebuild my front end application and then delete the current version of dist and re copy dist into my back end like that. And now I'll see those updates on my express server. So this is important because this is the thing that's going to be deployed into production. I still have this on local host. But now we can actually deploy this to the internet as one single application, just an express app that we're deploying. I'm going to deploy this app using railway. And before I do that, I'm going to set this up as a GitHub repo user app for YouTube video. I'm going to make this private. So I'm probably going to delete this after. But I'm going to create a GitHub repo for this. And then I'm going to add this as a repo. So I'll go over to my back end here, get in it, add a git ignore, get add everything, get commit a stupid message, add my origin, get pushed as you origin master. Okay. So my app should now be on GitHub. And it doesn't contain my dist folder. Why doesn't it contain my dist folder? Did I put dist in my git ignore? Well, that's not what I wanted. Okay. Well, let's get rid of that stupid commit message again. Okay. Now I should have, there we go, my entire express app with that dist folder, which means that if I deploy this to something like railway, which I'm going to do right now, deploy from GitHub repo, it should have everything in there. There's my user app deploy now. That looks like it was successfully deployed. So if we go to settings, generate a domain real quick, then this should be the app in a moment when it actually finishes deploying. There we go. So there is the entire app. All I have to do is deploy my express app. And if I go to the root of that, I will get my react application. But if I went to something like slash API slash users, I'll see the JSON API. So I have my react app and my JSON API as one express application that I can now deploy anywhere. And there are many ways to deploy a react app. This is not the standard way. It isn't a suggested way. It's just one of many ways. But if this happens to be your plan for deploying your react app, to proxy your API requests is a really nice feature that your toolchain has.